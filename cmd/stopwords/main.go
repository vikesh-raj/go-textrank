package main

import (
	"bufio"
	"fmt"
	"os"
	"sort"
	"strings"
	"text/template"
)

func usage() {
	fmt.Fprintf(os.Stderr, "Usage: stopwords <input> <output> <package> <variable>\n")
	os.Exit(1)
}

func main() {

	if len(os.Args) != 5 {
		usage()
	}

	err := run(os.Args[1:])
	if err != nil {
		fmt.Fprintf(os.Stderr, "error: %v\n", err)
		os.Exit(1)
	}
}

const headerTemplate string = `package {{.Package}}

// Code generated by "stopwords {{.Args}}"; DO NOT EDIT

var {{.Variable}} = [...]string{
`

const footer string = `}
`

type opts struct {
	Package  string
	Variable string
	Args     string
}

func run(args []string) error {
	inputFile := args[0]
	outputGoFile := args[1]
	pkg := args[2]
	variable := args[3]
	words, err := readWords(inputFile)
	if err != nil {
		return err
	}
	sort.Strings(words)
	opts := opts{Package: pkg, Variable: variable, Args: strings.Join(args, " ")}
	return writeWords(outputGoFile, opts, unique(words))
}

func unique(words []string) []string {
	unique := make([]string, 0, len(words))
	for _, word := range words {
		pos := sort.SearchStrings(unique, word)
		if pos == len(unique) {
			unique = append(unique, word)
		}
	}
	return unique
}

func readWords(inputFile string) ([]string, error) {
	reader, err := os.Open(inputFile)
	if err != nil {
		return nil, fmt.Errorf("unable to open file : %s : %v", inputFile, err)
	}
	defer reader.Close()
	words := make([]string, 0)
	scanner := bufio.NewScanner(reader)
	for scanner.Scan() {
		words = append(words, string(scanner.Bytes()))
	}
	return words, nil
}

func writeWords(outputGoFile string, opts opts, words []string) error {

	writer, err := os.Create(outputGoFile)
	if err != nil {
		return fmt.Errorf("unable to create file : %s : %v", outputGoFile, err)
	}
	defer writer.Close()

	t := template.Must(template.New("").Parse(headerTemplate))
	t.Execute(writer, &opts)
	for _, word := range words {
		if word == "" {
			continue
		}
		fmt.Fprintf(writer, "\t\"%s\",\n", word)
	}

	fmt.Fprintf(writer, "%s", footer)
	return nil
}
